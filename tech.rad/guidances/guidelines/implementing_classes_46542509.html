<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="ru" xml:lang="ru">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Рекомендация: Реализация классов</title>
<meta content="Guideline" name="uma.type">
<meta content="implementing_classes" name="uma.name">
<meta content="Реализация классов" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "6.392513032248068E-306"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="6.392513032248068E-306"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Рекомендация: Реализация классов</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">В этих рекомендациях приведены инструкции по реализации классов с помощью среды моделирования RAD 6.0. </td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Взаимосвязи</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Связанные элементы</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/tasks/implement_component_AE366827.html" guid="{3293F4F7-EFCD-4476-BFF1-81AC3812B512}">Элементы проекта реализации</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Основное описание</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><div align="left">
    <ul>
        <li>
            <a href="#Implement Operations">Реализация операций</a>
        </li>
        <li>
            <a href="#Implement States">Реализация состояний</a>
        </li>
        <li>
            <a href="#Use Delegation to Reuse Implementation">Делегирование для повторного использования
            реализации</a>
        </li>
        <li>
            <a href="#Implement Associations">Реализация связей</a>
        </li>
        <li>
            <a href="#Implement Attributes">Реализация атрибутов</a>
        </li>
    </ul>
</div>
<h3>
    <a id="Implement Operations" href="#Implement Attributes" name="Implement Operations">Реализация операций</a>
</h3>
<p>
    Для реализации операций выполните следующие действия:
</p>
<ul>
    <li>
        Выберите алгоритм.
    </li>
    <li>
        Выберите структуры данных, соответствующие алгоритмам.
    </li>
    <li>
        При необходимости определите новые классы и операции.
    </li>
    <li>
        Создайте код операции.
    </li>
</ul>
<h5>
    Выбор алгоритма
</h5>
<p>
    Многие операции достаточно просты, поэтому их можно реализовать на основе операции и ее спецификации.
</p>
<p>
    Сложные алгоритмы в первую очередь необходимы по следующим причинам: для реализации сложных операций с заданной
    спецификацией, а также для оптимизации операций, определением которых служит простой, но неэффективный алгоритм.
</p>
<h5>
    Выбор структур данных, соответствующих алгоритмам
</h5>
<p>
    Выбор алгоритмов включает в себя выбор структуры данных, с которой работают эти алгоритмы. К структурам данных
    относятся классы контейнеров, например, массивы, списки, очереди, стеки, наборы, мультинаборы, а также разновидности
    этих элементов. Большинство языков и сред программирования, основанных на объектах, предусматривают библиотеки классов,
    где содержатся эти многоразовые компоненты.
</p>
<h5>
    Определение необходимых новых классов и операций
</h5>
<p>
    Новые классы могут содержать промежуточные результаты. Для разложения сложной операции к классу можно добавлять новые
    низкоуровневые операции. Эти операции часто являются частными для класса, то есть они не видны за пределами класса.
</p>
<h5>
    Кодирование операции
</h5>
<p>
    Создайте код операции, начинающийся с оператора интерфейса. Следуйте рекомендациям по программированию.
</p>
<h3>
    <a id="Implement States" href="#Top" name="Implement States">Реализация состояний</a>
</h3>
<p>
    Состояние объекта можно реализовать, создав ссылку на значения его атрибутов, без специального представления. У таких
    объектов нет явно выраженного понятия состояния, и их состояние зависит от совокупности значений атрибутов. Ввиду
    отсутствия формальных состояний, управление этими объектами осуществляется с помощью условных операторов. &nbsp;Этот
    метод не подходит для вариантов поведения, потому что он требует создания сложных структур, которые трудно изменять при
    добавлении или редактировании состояний.
</p>
<p>
    Если поведение элемента проектирования (или его составляющих) зависит от состояния, создается одна или несколько
    диаграмм состояний, в которых описано поведение элементов модели в элементе проектирования. Эти диаграммы служат важным
    источником входных данных в процессе реализации.
</p>
<p>
    В диаграммах состояний конечные автоматы отражают состояние объекта, переходы между состояниями и необходимое
    поведение. Конечные автоматы можно реализовать следующими способами:
</p>
<ul>
    <li>
        Простые конечные автоматы можно реализовать путем добавления значений атрибута, где перечислены возможные
        состояния, и использования этого атрибута для выбора поведения входящих сообщений. Например, конечные автоматы
        можно использовать в операторе переключений в Java или C++. Этот метод не очень подходит для сложных конечных
        автоматов и может привести к снижению производительности. Примеры применения этого метода приведены в разделе [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html" guid="7.755968586980351E-308">DOUG98</a>], в главе 4, 4.4.3.
    </li>
    <li>
        Для более сложных конечных автоматов можно использовать шаблон состояний. Описание шаблона состояний приведено в
        разделе [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html" guid="7.755968586980351E-308">GAM94</a>]. В разделе [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html" guid="7.755968586980351E-308">DOUG98</a>], в главе
        6, 6.2.3 <i>Шаблон состояний</i> также описан этот подход.
    </li>
    <li>
        Подход с использованием таблиц удобно использовать для очень сложных конечных автоматов, где необходима простота
        внесения изменений. В этом подходе для каждого состояния в таблице создаются записи. Каждая запись связывает
        входные данные с текущими состояниями и связанными операциями по переходу между состояниями. Пример применения
        этого метода приведен в разделе [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html" guid="7.755968586980351E-308">DOUG98</a>], в главе
        6, 6.2.3 <i>Шаблон таблицы состояний</i>.
    </li>
</ul>
<p>
    Конченые автоматы и сопутствующие дочерние состояния можно реализовать путем передачи контроля за состояниями активным
    объектам. При этом каждому объекту передается управление одним дочерним состоянием, потому что дочерние состояния
    требуют независимых вычислений (которые, тем не менее, могут пересекаться). Каждым дочерним состоянием можно управлять
    с помощью описанных выше методов.
</p>
<h3>
    <a id="Use Delegation to Reuse Implementation" href="./../../../core.base_rup/customcategories/references_56F06DFD.html" name="Use Delegation to Reuse Implementation" guid="7.755968586980351E-308">Делегирование для повторного использования
    реализации</a>
</h3>
<p>
    Если класс или его части можно реализовать путем повторного использования существующего класса, вместо наследования
    используйте делегирование.
</p>
<p>
    При делегировании класс реализуется с помощью других классов. Класс ссылается на объект другого класса с помощью
    переменной. За вызовом операции следует вызов операции в объекте повторно использованного класса, где происходит
    фактическое выполнение. Таким образом, выполнение делегируется и переносится из одного класса в другой.
</p>
<h3>
    <a id="Implement Associations" href="#Top" name="Implement Associations">Реализация связей</a>
</h3>
<p>
    Односторонняя связь реализуется как указатель, то есть как атрибут, который содержит ссылку на объект. Если для опции
    множественности задано значение <b>one</b>, то односторонняя связь реализуется как простой указатель. Если для этой
    опции задано значение <b>many</b>, то она реализуется как набор указателей. Если задано значение <b>many</b>, то вместо
    набора можно использовать список.
</p>
<p>
    Двусторонняя связь реализуется в виде атрибутов для обоих направлений. При этом используются методы создания
    односторонней связи.
</p>
<p>
    Полная связь реализуется в виде таблицы поиска (например, класс словаря Smalltalk) в дополняющем объекте. В таблице
    поиска значения селектора задаются спецификаторами, а целевые значения - объектами другого класса.
</p>
<p>
    Если доступ к значениям спецификаторов осуществляется в определенной последовательности, то спецификаторы можно
    сгруппировать в отсортированный массив или в древовидную структуру. В этом случае время доступа будет пропорционально
    протоколу N, где N - это количество значений спецификатора.
</p>
<p>
    Если спецификаторы заданы на основе компактного конечного множества, то их значения можно связать с областью
    целочисленных значений, и связь можно реализовать как массив. Этот подход удобно использовать, если связь заполнена
    почти полностью, а не частично, и он идеально подходит для полностью заполненных конечных множеств.
</p>
<p>
    Большинство языков и сред программирования, основанных на объектах, предусматривают библиотеки классов, где содержатся
    многоразовые компоненты, которые можно использовать для реализации связей разных видов.
</p>
<h3>
    <a id="Implement Attributes" href="#Top" name="Implement Attributes">Реализация атрибутов</a>
</h3>
<p>
    Атрибуты можно реализовать одним из трех способов: с помощью простых встроенных типов, существующего класса или нового
    класса. Обычно удобнее всего создание нового класса, но этот метод требует осуществления косвенного вызова. Например,
    номер пенсионного страхования сотрудника можно реализовать как атрибут класса String или как новый класс.
</p>
<p class="picturecenter" align="center">
    <img height="37" alt="Пример альтернативных реализаций атрибутов" src="./../../../tech.rad/guidances/guidelines/resources/ac_impc1.gif" width="430"     border="0" />
</p>
<p class="picturetext" align="center">
    Альтернативные реализации атрибута.
</p>
<p>
    Иногда новые классы создаются на основе групп атрибутов, как показано в следующем примере. Обе реализации верны.
</p>
<p class="picturecenter" align="center">
    <img height="78" alt="Атрибуты реализации элемента Line класса Point" src="./../../../tech.rad/guidances/guidelines/resources/ac_impc2.gif" width="381" />
</p>
<p class="picturetext" align="center">
    Атрибуты элемента Line реализованы в соответствии с классом Point.<br />
</p></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Все права защищены..
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
